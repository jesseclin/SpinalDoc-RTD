.. role:: raw-html-m2r(raw)
   :format: html

.. _fiber:

Fiber framework
====================

.. warning::
   このフレームワークは一般的な RTL 生成には使用されないことが想定されており、
   大規模なシステム設計管理とコード生成を対象としています。
   現在は SaxonSoC でトップレベルの統合ツールとして使用されています。

現在開発中です。

ハードウェアの詳細な作成を順不同に実行するためのファイバーは、
Makefile に少し似ており、ルールと依存関係を定義し、その後、make コマンドを実行すると解決されます。
Scala Future 機能と非常に似ています。

このフレームワークを使用すると、単純なことを複雑にすることができますが、複雑なケースにはいくつかの強力な機能を提供します：

- すべての要件を完全に把握する前にも、事柄を定義できます。
  例：必要な割り込み信号線の数を知らないまま割り込みコントローラーをインスタンス化する
- 抽象的で遅延された/部分的な SoC アーキテクチャの定義により、SoC テンプレートの作成が可能になります
- 分散型で複数のエージェント間の要件交渉を自動化します。例：メモリバスのマスターとスレーブ間での自動要件交渉

このフレームワークは主に次のようなもので構成されています：

- ``Handle[T]``：後で型 ``T`` の値を格納するために使用できます。
- ``handle.load``：ハンドルの値を設定することができます（これにより、それに待機しているすべてのタスクが再スケジュールされます）
- ``handle.get``：指定されたハンドルの値を返します。そのハンドルがまだロードされていない場合、タスクの実行がブロックされます
- ``Handle{ /*code*/ }``：指定されたコードを実行する新しいタスクをフォークします。そのコードの結果は Handle にロードされます
- ``soon(handle)``：現在のタスクが ``handle`` を値でロードすることを発表できるようにします（スケジューリングに使用されます）
 
シンプルなダミーの例
--------------------

シンプルな例があります：

.. code-block:: scala

  import spinal.core.fiber._

  // ２つの空のハンドルを作成する
  val a, b = Handle[Int] 

  // 指定されたボディの結果によって非同期にロードされるハンドルを作成する
  val calculator = Handle {  
      a.get + b.get // .get は、ロードされるまでブロックされます
  }

  // 上記と同じ
  val printer = Handle {
      println(s"a + b = ${calculator.get}") // .get は、calculator ボディの実行が完了するまでブロックされま
  }

  // a と b を同期的にロードすると、a.get と b.get がアンブロックされます
  a.load(3)
  b.load(4)

ランタイムは次のようになります：

- a と b を作成する
- calculator タスクをフォークするが、 a.get を実行するとブロックされる
- printer タスクをフォークするが、 calculator.get を実行するとブロックされる
- a と b をロードし、 calculator タスクを再スケジュールする（a に待機していたため）
- calculator は a + b の合計を実行し、その結果を持つハンドルをロードし、printer タスクを再スケジュールします
- printer タスクはその内容を印刷します
- すべての処理が完了します

したがって、この例の主なポイントは、a と b が calculator の定義の後にロードされるという順序実行をある程度克服したことを示すことです。

Handle[T]
--------------------

Handle[T] は、scala の Future[T] に少し似ています。
それらは、まだ存在しないものについて話すことを可能にし、それを待つことができます。

.. code-block:: scala
    
    val x,y = Handle[Int]
    val xPlus2 : Handle[Int] = x.produce(x.get + 2) // x がロードされると、x.produce は新しいハンドルを生成するために使用できます
    val xPlus3 : Handle[Int] = x.derivate(_ + 3)    // x.derivate は x.produce と同じですが、x.get を lambda 関数の引数として提供します
    x.load(3) // x は今、値 3 を含んでいます


soon(handle)
^^^^^^^^^^^^^^^^^^^^

タスクとハンドルの間の依存関係の適切なグラフを維持するために、タスクは事前に指定して、
特定のハンドルをロードすることを示すことができます。
これは、 SpinalHDL において生成の停滞やデッドロックが発生した場合に、
問題がどこにあるかを正確に報告するために非常に役立ちます。




