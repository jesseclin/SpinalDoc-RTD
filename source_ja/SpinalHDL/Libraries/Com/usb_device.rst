
USB device
==========

SpinalHDL ライブラリには USB デバイスコントローラーが存在します。

サポートの要約をまとめるためのいくつかの要点：

- CPU がエンドポイントを設定および管理できるように実装されています
- エンドポイントの状態とトランザクションディスクリプタを格納する内部 RAM
- 仮想的に追加費用なしで最大 16のエンドポイントをサポート
- USB ホストフルスピード（12Mbps）をサポート
- 独自のドライバを使用して Linux でテスト済み（https://github.com/SpinalHDL/linux/blob/dev/drivers/usb/gadget/udc/spinal_udc.c）
- 構成用の Bmb メモリインターフェイス
- 内部 PHY のクロックは少なくとも 12 MHzの倍数である必要がありますが、48 MHz以上である必要があります
- コントローラーの周波数に制限はありません
- 外部 PHY は不要です

Linux ガジェットがテストされ、機能しています：

- シリアル接続
- イーサネット接続
- マスストレージ（ArtyA7 linuxで約8 Mbps）
  
デプロイメント：

- https://github.com/SpinalHDL/SaxonSoc/tree/dev-0.3/bsp/digilent/ArtyA7SmpLinux
- https://github.com/SpinalHDL/SaxonSoc/tree/dev-0.3/bsp/radiona/ulx3s/smp


Architecture
------------

コントローラーは次のように構成されています：

- 数個の制御レジスタ
- エンドポイントの状態、転送記述子、エンドポイント 0 の SETUP データを格納するために使用される内部 RAM

USB IN/OUT トランザクションとデータを処理するために、各エンドポイントに対してディスクリプタのリンクリストがあります。

エンドポイン ト0は、他のエンドポイントと同様に IN/OUT トランザクションを処理しますが、
SETUP トランザクションを処理するための追加のハードウェアがあります：

- 各セットアップトランザクションでリンクリストがクリアされます
- SETUP トランザクションのデータは固定の位置（SETUP_DATA）に格納されます
- SETUP トランザクション用の特定の割り込みフラグがあります

Registers
---------

コントローラーのすべてのレジスターとメモリは、
32 ビットのワードアクセスのみ可能であり、バイトアクセスはサポートされていません。

FRAME (0xFF00)
**********************

+-------------------------+------+-----------+------------------------------------------------------------------+
| Name                    | Type | Bits      | Description                                                      |
+=========================+======+===========+==================================================================+
| usbFrameId              |  RO  | 31-0      | Current usb frame id                                             |
+-------------------------+------+-----------+------------------------------------------------------------------+


ADDRESS (0xFF04)
**********************

+-------------------------+------+-----------+------------------------------------------------------------------+
| Name                    | Type | Bits      | Description                                                      |
+=========================+======+===========+==================================================================+
| address                 |  WO  | 6-0       | The device will only listen at tokens with the specified address |
|                         |      |           | This field is automaticaly cleared on usb reset events           |
+-------------------------+------+-----------+------------------------------------------------------------------+
| enable                  |  WO  | 8         | Enable the USB address filtering if set                          |
+-------------------------+------+-----------+------------------------------------------------------------------+
| trigger                 |  WO  | 9         | Set the enable (see above) on the next EP0 IN tocken completion  |
|                         |      |           | Cleared by the hardware after any EP0 completion                 |
+-------------------------+------+-----------+------------------------------------------------------------------+

ここでのアイデアは、USB の SET_ADDRESS セットアップパケットが EP0 で受信されるまで、レジスタ全体をクリアしたままにしておくことです。
その時点で、アドレスとトリガー フィールドを設定し、次に IN ゼロ長記述子を EP0 に提供して、SET_ADDRESS シーケンスを完了させます。
その記述子の完了時にコントローラーは、自動的にアドレスフィルタリングをオンにします。

INTERRUPT (0xFF08)
**********************

このレジスタの個々のビットは、それぞれに '1' を書き込むことでクリアできます。
このレジスタを読み取ると、現在の割り込み状態が返されます。

+--------------+-------+-----------+------------------------------------------------------------------+
| Name         | Type  | Bits      | Description                                                      |
+==============+=======+===========+==================================================================+
| endpoints    |  W1C  | 15-0      | Raised when an endpoint generates an interrupt                   |
+--------------+-------+-----------+------------------------------------------------------------------+
| reset        |  W1C  | 16        | Raised when a USB reset occurs                                   |
+--------------+-------+-----------+------------------------------------------------------------------+
| ep0Setup     |  W1C  | 17        | Raised when endpoint 0 receives a setup transaction              |
+--------------+-------+-----------+------------------------------------------------------------------+
| suspend      |  W1C  | 18        | Raised when a USB suspend occurs                                 |
+--------------+-------+-----------+------------------------------------------------------------------+
| resume       |  W1C  | 19        | Raised when a USB resume occurs                                  |
+--------------+-------+-----------+------------------------------------------------------------------+
| disconnect   |  W1C  | 20        | Raised when a USB disconnect occurs                              |
+--------------+-------+-----------+------------------------------------------------------------------+

HALT (0xFF0C)
**********************

このレジスタは、単一のエンドポイントを休止状態に配置し、CPU 操作のアトミシティを確保することを可能にします。
これにより、エンドポイントレジスタやディスクリプタの読み取り/変更/書き込みなどの操作が行えます。
このペリフェラルは、エンドポイントが有効になっており、休止が有効になっている場合、
および USB ホストが該当するエンドポイントにアクセスしようとした場合に、NAK を返します。

+-------------------------+------+-----------+------------------------------------------------------------------+
| Name                    | Type | Bits      | Description                                                      |
+=========================+======+===========+==================================================================+
| endpointId              |  WO  | 3-0       | The endpoint you want to put in sleep                            |
+-------------------------+------+-----------+------------------------------------------------------------------+
| enable                  |  WO  | 4         | When set halt is active, when clear endpoint is unhalted.        |
+-------------------------+------+-----------+------------------------------------------------------------------+
| effective               |  RO  | 5         | After setting the enable, you need to wait for this bit to be    |
| enable                  |      |           | set by the hardware itself to ensure atomicity                   |
+-------------------------+------+-----------+------------------------------------------------------------------+

CONFIG (0xFF10)
**********************

+-------------------------+------+-----------+------------------------------------------------------------------+
| Name                    | Type | Bits      | Description                                                      |
+=========================+======+===========+==================================================================+
| pullupSet               |  SO  | 0         | Write '1' to enable the USB device pullup on the dp pin          |
+-------------------------+------+-----------+------------------------------------------------------------------+
| pullupClear             |  SO  | 1         |                                                                  |
+-------------------------+------+-----------+------------------------------------------------------------------+
| interruptEnableSet      |  SO  | 2         | Write '1' to let the present and future interrupt happening      |
+-------------------------+------+-----------+------------------------------------------------------------------+
| interruptEnableClear    |  SO  | 3         |                                                                  |
+-------------------------+------+-----------+------------------------------------------------------------------+

INFO (0xFF20)
**********************

+---------------+------+-----------+------------------------------------------------------------------+
| Name          | Type | Bits      | Description                                                      |
+===============+======+===========+==================================================================+
| ramSize       |  RO  | 3-0       | The internal ram will have (1 << this) bytes                     |
+---------------+------+-----------+------------------------------------------------------------------+

ENDPOINTS (0x0000 - 0x003F)
*********************************

エンドポイントの状態は、内部 RAM の先頭に、それぞれ 1つの 32ビットワードで格納されています。

+---------------+------+-----------+------------------------------------------------------------------+
| Name          | Type | Bits      | Description                                                      |
+===============+======+===========+==================================================================+
| enable        |  RW  | 0         | If not set, the endpoint will ignore all the trafic              |
+---------------+------+-----------+------------------------------------------------------------------+
| stall         |  RW  | 1         | If set, the endpoint will always return STALL status             |
+---------------+------+-----------+------------------------------------------------------------------+
| nack          |  RW  | 2         | If set, the endpoint will always return NACK status              |
+---------------+------+-----------+------------------------------------------------------------------+
| dataPhase     |  RW  | 3         | Specify the IN/OUT data PID used. '0' => DATA0.                  |
|               |      |           | This field is also updated by the controller.                    |
+---------------+------+-----------+------------------------------------------------------------------+
| head          |  RW  | 15-4      | Specify the current descriptor head (linked list).               |
|               |      |           | 0 => empty list, byte address = this << 4                        |
+---------------+------+-----------+------------------------------------------------------------------+
| isochronous   |  RW  | 16        |                                                                  |
+---------------+------+-----------+------------------------------------------------------------------+
| maxPacketSize |  RW  | 31-22     |                                                                  |
+---------------+------+-----------+------------------------------------------------------------------+

エンドポイントを応答可能にするには、次の手順が必要です：

- その有効フラグを 1 に設定します

その後、いくつかのケースがあります：

- ストールまたは NACK フラグが設定されている場合、コントローラは常に対応する応答で応答します
- EP0 のセットアップリクエストの場合、コントローラはディスクリプタを使用せず、代わりにデータを SETUP_DATA レジスタに書き込み、ACK を返します
- 空のリンクリスト（head == 0）の場合、NACK で応答します
- head が指す少なくとも 1つのディスクリプタがある場合、それを実行し、すべてが順調に進んだ場合は ACK を返します

SETUP_DATA (0x0040 - 0x0047)
*********************************

エンドポイント 0 が SETUP トランザクションを受信すると、トランザクションのデータはこの場所に格納されます。

Descriptors 
-----------

ディスクリプタは、IN/OUT トランザクションのデータフェーズをどのように処理するかを指定するためのものです。
これらは内部 RAM に格納され、リンクリストを介して連結されることができ、16 バイト境界に整列する必要があります。

+-------------------+------+-----------+------------------------------------------------------------------+
| Name              | Word | Bits      | Description                                                      |
+===================+======+===========+==================================================================+
| offset            | 0    | 15-0      | Specify the current progress in the transfer (in byte)           |
+-------------------+------+-----------+------------------------------------------------------------------+
| code              | 0    | 19-16     | 0xF => in progress, 0x0 => success                               |
+-------------------+------+-----------+------------------------------------------------------------------+
| next              | 1    | 15-4      | Pointer to the next descriptor                                   |
|                   |      |           | 0 => nothing, byte address = this << 4                           |
+-------------------+------+-----------+------------------------------------------------------------------+
| length            | 1    | 31-16     | Number of bytes allocated for the data field                     |
+-------------------+------+-----------+------------------------------------------------------------------+
| direction         | 2    | 16        | '0' => OUT, '1' => IN                                            |
+-------------------+------+-----------+------------------------------------------------------------------+
| interrupt         | 2    | 17        | If set, the completion of the descriptor will generate an        |
|                   |      |           | interrupt.                                                       |
+-------------------+------+-----------+------------------------------------------------------------------+
| completionOnFull  | 2    | 18        | Normally, a descriptor completion only occurs when a USB transfer|
|                   |      |           | is smaller than the maxPacketSize. But if this field is set,     |
|                   |      |           | then when the descriptor become full is also a considered        |
|                   |      |           | as a completion event. (offset == length)                        |
+-------------------+------+-----------+------------------------------------------------------------------+
| data1OnCompletion | 2    | 19        | force the endpoint dataPhase to DATA1 on the completion of the   |
|                   |      |           | descriptor                                                       |
+-------------------+------+-----------+------------------------------------------------------------------+
| data              | ...  | ...       |                                                                  |
+-------------------+------+-----------+------------------------------------------------------------------+

注意：コントローラーが、IN/OUT がディスクリプタの IN/OUT と一致しないフレームを受信した場合、そのフレームは無視されます。

また、ディスクリプタを初期化するには、CPU はコードフィールドを 0xF に設定する必要があります。

Usage
-----

.. code-block:: scala

    import spinal.core._
    import spinal.core.sim._
    import spinal.lib.bus.bmb.BmbParameter
    import spinal.lib.com.usb.phy.UsbDevicePhyNative
    import spinal.lib.com.usb.sim.UsbLsFsPhyAbstractIoAgent
    import spinal.lib.com.usb.udc.{UsbDeviceCtrl, UsbDeviceCtrlParameter}


    case class UsbDeviceTop() extends Component {
      val ctrlCd = ClockDomain.external("ctrlCd", frequency = FixedFrequency(100 MHz))
      val phyCd = ClockDomain.external("phyCd", frequency = FixedFrequency(48 MHz))

      val ctrl = ctrlCd on new UsbDeviceCtrl(
        p = UsbDeviceCtrlParameter(
          addressWidth = 14
        ),
        bmbParameter = BmbParameter(
          addressWidth = UsbDeviceCtrl.ctrlAddressWidth,
          dataWidth = 32,
          sourceWidth = 0,
          contextWidth = 0,
          lengthWidth = 2
        )
      )

      val phy = phyCd on new UsbDevicePhyNative(sim = true)
      ctrl.io.phy.cc(ctrlCd, phyCd) <> phy.io.ctrl

      val bmb = ctrl.io.ctrl.toIo()
      val usb = phy.io.usb.toIo()
      val power = phy.io.power.toIo()
      val pullup = phy.io.pullup.toIo()
      val interrupts = ctrl.io.interrupt.toIo()
    }


    object UsbDeviceGen extends App{
      SpinalVerilog(new UsbDeviceTop())
    }


