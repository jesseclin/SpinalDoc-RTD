==========================
Simulator specific details
==========================

SpinalHDL が Verilator バックエンドでハードウェアをシミュレートする方法
===========================================================================

1. SpinalHDL は、DUT の Verilog 相当のハードウェアモデルを生成し、それを C++ サイクル正確なモデルに変換するためにVerilatorを使用します。
2. C++ モデルは、Scala と JNI-FFI を介してバインドされた共有オブジェクト (.so) にコンパイルされます。
3. ネイティブの Verilator API は、シミュレーションのマルチスレッド API を提供することで抽象化されます。

**利点:**

* Verilator バックエンドは、コンパイルされた C++ シミュレーションモデルを使用するため、他のほとんどの商用および無料のシミュレータと比較してシミュレーション速度が速いです。

**制限:**

* Verilator は、合成可能な Verilog/System Verilog コードのみを受け入れます。そのため、非合成可能なステートメントを含む Verilog ブラックボックスコンポーネントをシミュレートする際には特別な注意が必要です。
* VHDL のブラックボックスはシミュレートできません。
* シミュレーションの起動プロセスは、生成された C++ モデルをコンパイルおよびリンクする必要があるため、遅くなります。最初のビルド後、後続のシミュレーションを高速化できるように、インクリメンタルなコンパイルおよびリンクをサポートするものが一部存在します。


SpinalHDL が GHDL/Icarus Verilog バックエンドでハードウェアをシミュレートする方法
===================================================================================

1. 選択したシミュレータに応じて、SpinalHDL は DUT の Verilog または VHDL ハードウェアモデルを生成します。
2. HDL モデルがシミュレータにロードされます。
3. シミュレーションと JVM 間の通信は、共有メモリを介して確立されます。コマンドは、 `VPI <https://en.wikipedia.org/wiki/Verilog_Procedural_Interface>`_ を使用してシミュレータに発行されます。

**利点:**

* GHDL と Icarus Verilog の両方が、非合成可能な HDL コードを受け入れることができます。
* シミュレーションの起動プロセスは、Verilator と比較してかなり高速です。

**制限:**

* GHDL は VHDL コードのみを受け入れます。そのため、このシミュレータでは VHDL ブラックボックスのみを使用できます。
* Icarus Verilog は Verilog コードのみを受け入れます。そのため、このシミュレータでは Verilog ブラックボックスのみを使用できます。
* シミュレーション速度は、Verilator と比較して約1桁遅くなります。

最後に、ネイティブの Verilator API はかなり原始的なため、SpinalHDL はユーザーがテストベンチの実装を構築するのを支援するために、
単一およびマルチスレッドのシミュレーション API の両方を提供することでこれを抽象化しています。

SpinalHDL が Synopsys VCS バックエンドでハードウェアをシミュレートする方法
==============================================================================

1. SpinalHDL は、DUT の選択に応じて Verilog/VHDL のハードウェアモデルを生成します。
2. HDL モデルがシミュレータにロードされます。
3. シミュレーションと JVM 間の通信は、共有メモリを介して確立されます。コマンドは、 `VPI <https://en.wikipedia.org/wiki/Verilog_Procedural_Interface>`_ を使用してシミュレータに発行されます。

**利点:**

* SystemVerilog/Verilog/VHDL のすべての言語機能をサポートします。
* 暗号化された IP をサポートします。
* FSDB ウェーブ形式のダンプをサポートします。
* コンパイルおよびシミュレーションの両方で高い性能を発揮します。

**制限:**

* Synopsys VCS は商用のシミュレーションツールです。クローズドソースであり、無料ではありません。法的に使用するにはライセンスを所有している必要があります。

VCS をシミュレーションバックエンドとして使用する前に、システム環境を確認するために :ref:`VCS environment<vcs_env>` をチェックしてください。

SpinalHDL が Xilinx XSimバ ックエンドでハードウェアをシミュレートする方法
=========================================================================

1. SpinalHDL は、DUT の選択に応じて Verilog/VHDL のハードウェアモデルを生成します。
2. HDL モデルがシミュレータにロードされます。
3. シミュレーションと JVM 間の通信は、共有メモリを介して確立されます。コマンドは、XSI を使用してシミュレータに発行されます。

**利点:**

* Xilinx の組み込みプリミティブとコアをサポートします。

**制限:**

* Xilinx XSim は、Vivado と一緒にインストールされる商用ツールです。クローズドソースであり、使用するためにはライセンス条項が適用されます。法的に使用するにはライセンスを所有している必要があります。
* Vivado 2019.1 より前のバージョンは正常に動作しません。

XSim をシミュレーションバックエンドとして使用する前に、以下の手順を実行していることを確認してください。
1. VIVADO_HOME 環境変数を定義して、vivado がどこにあるかを指定します。例： `export VIVADO_HOME=/d/Xilinx/Vivado/2022.1` (MSYS2の場合)。
2. 2つの vivado パスが PATH に含まれていることを確認します。Windows MSYS2ユーザーの場合、シェルコマンドを実行します。例： `export PATH=$PATH:$VIVADO_HOME/bin:$VIVADO_HOME/lib/win64.o` 。Linux ユーザーの場合は、Vivado の settings64.sh ファイルをソースにします。ファイルの場所は `VIVADO_HOME` 内です。

性能
===========

高性能なシミュレーションが必要な場合は、バックエンドとして Verilator を使用する必要があります。例えば `Murax <https://github.com/SpinalHDL/VexRiscv>`_ のような小さなSoCでは、Intel® Core™ i7-4720HQ は秒間 120 万クロックサイクルをシミュレートできます。しかし、DUT が単純で、数千クロックサイクルしかシミュレートする必要がない場合は、GHDL や Icarus Verilog を使用した方がシミュレーションのロードオーバーヘッドが低いため、より良い結果が得られる場合があります。
